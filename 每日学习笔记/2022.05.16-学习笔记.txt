                                                 2022.05.16 学习笔记
测试Flink 中的检查点
    状态的检查点，通过 env 进行设置
        env.enableCheckpointing(time)             : 给定义一个时间，来设置周期型的保存状态，设置这样的检查点
        env.setStateBackend(new FsStateBackend()) : 设置检查点的存放位置
    Flink 中状态通过检查点进行保存的逻辑：
        1）作业管理器，向输入数据源的多个并行子任务注入检查点分界线
        2）检查点分界线路过哪个并行子任务，就保存哪个子任务的状态快照
        3）分流时，将检查点分界线广播发送出去
        4）合流时，检查点分界线对齐
        5）合流时，接收到所有的检查点分界线后，才会做快照
        6）合并成为一个，才会往下游sink进行发送，然后对 sink 做快照
        7）每一个并行子任务都做完快照后
        8）会向作业管理器发送通知
        9）作业管理器接收到所有并行子任务的通知后，确认本次检查点完成
        10）将上一次的检查点文件删除，保留本次的检查点文件
        11）同时向所有的并行子任务广播一条本次检查点快照保存完成的通知
    Flink对于自身来说，是可以保证 Exactly-Once 的，但是对于连接上下游时，其保证Exactly-Once ，是通过两阶段提交来保证的，
    下游的组件
        1、需要实现 TwoPhaseCommitSinkFunction 抽象类，保证两阶段提交
        2、幂等性 Sink
        核心思想：
            1）第一个检查点保存完成，开启一个新的事务
            2）第一个检查点与下一个检查点之间所有要输出的数据，都缓存到下游的事务当中
            3）这个过程称之为预提交
            4）等到第二个检查点保存完成
            5）sink接收到了 作业管理器广播的检查点保存完成的通知，然后就把事务正式commit
            6）数据就正式落盘了
            7）如果预提交阶段，宕机了，那么事务中所有的数据都会被回滚掉
            8) 从第一个检查点处重新执行，之前的数据会再一次被提交

    状态一致性
    容错机制

    保存点和检查点的底层原理是相同的：
        分布式异步快照算法
    保存点是需要手动实现的， 检查点是自动实现的

    保存点最常用的场景
    热更新：
       在程序运行的过程中， 保存一个保存点。
       原来旧的程序不停止，然后从保存点开启一个新的程序。
       如果发现新的程序计算的结果的准确性更高，效率更好，则将旧程序停止。使用新程序。
       这就叫做热更新