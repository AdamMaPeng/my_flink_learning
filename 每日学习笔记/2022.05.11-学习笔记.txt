                                                            2022.05.11 学习笔记
第 9 章 状态编程
9.1 Flink 中的状态
    官网中对Flink 的定义： 有状态的流式计算
    1、状态 ： 就是之前的数据 或之前数据计算的结果进行保存。
            每个任务进行计算处理时，可以基于当前数据直接转换得到输出结果；也可以依赖一些其他数据。这些由一个任务维护，并且用来计算输出结果的
            所有数据，就叫做这个任务的状态

    2、获取状态：能获取到状态的，只能从 运行时上下文中获取状态，所以必须通过富函数及其子类的对象进行获取
    3、有状态的算子：执行任务时，除了当前的数据，还需要一些其他数据来得到结果，这个其他数据，就是所谓的状态，用到状态的算子，就叫有状态的算子
            所有的窗口算子（窗口要收集数据，将数据保留，必然存在状态），
            所有的 ProcessFunction 及其子类（因为所有的ProcessFunction都继承自AbstractRichFunction）
            reduce、aggregate

       无状态的算子：只需要关注每个独立的事件，根据当前输入的结果直接转换输出结果
            map / fliter/ flatMap

    4、所有的算子都有其富函数类 ，所以并不是说 无状态算子就一定不能有状态，状态可以自定义，只不过获取状态必须从 运行时上下文中 Context 中获取
        也就是通过如下的方式：
            getRuntimeContext().getState(
                                new ValueStateDescriptor<Tuple3<String, String, Long>>()

9.1.2 状态的管理
    1、状态的管理是基于 key 的。
        比如 wordCount ，如果每个分区只有一个 状态，默认的分区规则下，keyBy 后，可能多个不同的key 分到同一个分区中，那么计算wordCount 是，针对不同的
        key 则会不进行区分，而进行count ，所以状态是基于key 的
    2、状态也是要持久化的，保证了容错性
        当发生错误，进行恢复的时候，按照Flink 将状态保存到内存中，如果只是保存在内存中，如果发生故障，则发生故障的节点的状态就丢失了，所以Flink
        的状态也是进行持久化保存的
    3、分布式扩展中，状态也是要进行重组调增的。
        当数据量特别大，集群资源不足的时候，需要进行横向扩展，如果状态不发生改变，只将数据发送到新增加的节点上，那么效率也就没法保障，所以对应的
        状态也是需要进行重组调整的

9.1.3 状态的分类
  1、托管状态（Managed State）和 原始状态（Raw State）
    1、托管状态（Managed State）
        1） 由 Flink 统一管理的，由Flink 的 运行时 Runtime 来托管的
        2） 状态的存储访问、故障恢复、重组等都是由 Flink 实现，我们只要调用接口即可
        3） 配置容错机制后，状态会自动持久化保存，并在发生故障时自动恢复
        4） 应用横向扩展时，状态会自动地重组分配到所有的子任务实例上。
        5） 根据具体的状态内容，分为
                值状态（ValueState）
                列表状态（ListState）
                映射状态（MapState）
                聚合状态（AggregateState）
            内部支持各种数据类型。


    2、原始状态（Raw State） （不推荐使用）
        1）自定义的，相当于开辟一块内存，需要我们自己管理，实现状态的序列化和故障恢复
        2）Flink 将 原始状态 当作最原始的字节（Byte）数组来存储。

  2、算子状态（Operator State） 和案件分区状态（Keyed State）