                                             2022.05.07 学习笔记
第 6  章 ： Flink 中的时间和窗口
    窗口：     划定的一段时间范围 --- 时间窗 （窗口 和时间 往往是分不开的）
    窗口计算：  对这个范围内的数据进行处理

6.1、时间语义：
    1、Flink 中存在的时间语义为：
        事件时间、处理时间、摄入时间

        事件时间 （Event Time）       ： 数据产生的时间
            1）指每个事件在对应的设备上发生的时间
            2）数据产生，时间自然确定，将时间作为一个属性嵌入到数据中，也就是这个数据的“时间戳”（TimeStamp）
            3）由于网络传输延迟的不确定性，数据流往往是乱序的。
               这种情况下，就不能简单的把数据自带的时间戳当作时钟了，而需要另外的标志来
               表示事件时间进展。 在Flink 中把它叫做事件时间 的 水位线（Watermark）

        处理时间 （Processing Time）  ： 数据真正被处理的时刻
            1）指执行处理操作的机器的系统时间
            2）每个并行的窗口子任务，只按照自己的系统时钟划分窗口

        摄入时间（Ingestion Time）    ： 数据进入 Flink 数据流的时间，也就是 Source 算子读入数据的时间
            1）水位线（watermark）基于这个时间直接生成，不需要单独指定
            2）这种时间语义可以保证比较好的正确性，同时不会引入太大的延迟

        时间语义（Notions Of Time）   ： 我们定义的窗口操作，到底是以哪种时间作为衡量标准

        （由于分布式系统中网络传输的延迟和时钟漂移，处理时间 相对事件发生时间会有滞后）

    2、数据处理系统中的时间语义
        1）实际应用中，事件时间语义会更为常见。一般情况下，业务日志数据中都会记录数据生成的时间戳（TimeStamp），
          它就可以作为事件时间的判断基础

    3、两种时间语义的对比
        1）背压（back pressure） ： 数据量过大、处理能力不足，短时间堆了大量数据处理不完，产生背压

        2）通常 处理时间是我们计算效率的衡量标准

        3） 处理时间的应用：由于不用考虑任何情况，数据一来就进行处理，这种凡是可以 让我们的流处理延迟降到最
        低，效率达到最高。

        4）事件时间语义下， 水位线成为了时钟，可以统一控制事件的进度

        5）采用事件时间 + 窗口，数据还是可能乱序的，要想让窗口正确的收集到所有的数据，就必须等这些错乱的数据都到齐
        就需要一定的等待时间

        6）事件时间语义是以一定延迟为代价，换来了处理结果的正确性

        7）事件时间在实际应用中更为广泛，所以从 1.12 版本开始， Flink 已经将事件事件作为了默认的时间语义

6.2 水位线（Watermark）
        1）水位线： 用来度量事件时间的一种度量值

     6.2.1 时间时间和窗口
        1）实际应用中，一般会采用事件时间的语义
        2）水位线基于事件时间提出的概念

     6.2.2 什么是 水位线
        例如一个时间戳为 9点整的数据到来，当前任务的时钟就已经是 9 点了；
        处理完当前数据要发送到下游，如果下游
        任务是一个窗口计算，并行度为 3，那么接收到这个数据的子任务，时钟也会进展到 9 点，9
        点结束的窗口就可以关闭进行计算了；而另外两个并行子任务则时间没有变化，不能进行窗口
        计算。
        所以我们应该把时钟也以数据的形式传递出去，告诉下游任务当前时间的进展；而且这个
        时钟的传递不会因为窗口聚合之类的运算而停滞。一种简单的想法是，在数据流中加入一个时
        钟标记，记录当前的事件时间；这个标记 可以直接广播到下游，当下游任务收到这个标记，就
        可以更新自己的时钟了。由于类似于水流中用来做标志的记号，在 Flink 中，这种用来衡量事
        件时间（Event Time）进展的标记，就被称作“水位线”（Watermark）。

        即使数据不再往下游走了，但是水位线依然会往下游发送

        2、当前一个数据的时间戳为 第5秒的，如果出现下游有多个子任务的情形，我们只要将水位线广播出去，就可以通知
        到所有下游任务当前的时间进度了

        3、实际应用中，
            当数据量特别大时，大量数据的时间戳是相同的，这时就会记录大量相同的时间戳，做了无用功降低了效率。
            当数据量特别小的时候，很久都不更新水位线，时钟不发生变化，这样对系统来说也是不够好的
            为了提高效率，一般会每隔一段时间生成一个是水位线，这个水位线的时间戳就是当前最新数据的时间戳

            1、有序流中的水位线：
                对于水位线的周期生成，周期时间就是指处理时间（系统时间），而不是事件时间
                该情况只存在与理想状态下

            2、乱序流中的水位线
                 分布式场景下，数据在各个节点间传输，会因为网络传输延迟的不确定性，导致顺序发生改变，这既是
                 所谓的“乱序数据”

                 乱序：数据的先后顺序不一致，主要就是基于数据的产生时间而言的

                 9秒的数据比 7 秒的数据来的早： 7秒的数据传输和缓存时间 》 9 秒的数据

                解决思路：
                    1、没来一个数据就提取他的时间戳，插入一个水位线
                    2、当前数据乱序，所以插入水位线要判断当前数据的时间戳是否比之前的时间戳大，否则就不再生成新的水位线
                    3、只有数据的时间戳比当前时钟大，才能推动时钟前进，这时才会才入水位线

                周期性生成：
                    1、还是没来一条数据记录一下时钟
                    2、当周期性触发记录水位线的时候，把记录中最大的时钟作为当前这一个周期的水位线

                解决数据传输速度不一致问题：
                    1、在周期性生成水位线的基础上，根据经验稍微等一会
                    2、让迟到的数据可以落在他应该在的窗口中

                改进版：
                    之前的做法是，来了9秒的数据，我们需要等2秒钟，
                    现在的做法，还是 9 秒中进行关窗，只不过此时插入水位线是 9秒之前 2 秒钟的水位线
                    这样的话，窗口的行为可以不变，该几点中关几点中关，但是不会响应我们的效果

                水位线特性：
                    ⚫ 水位线是插入到数据流中的一个标记，可以认为是一个特殊的数据
                    ⚫ 水位线主要的内容是一个时间戳，用来表示当前事件时间的进展
                    ⚫ 水位线是基于数据的时间戳生成的
                    ⚫ 水位线的时间戳必须单调递增，以确保任务的事件时间时钟一直向前推进
                    ⚫ 水位线可以通过设置延迟，来保证正确处理乱序数据
                    ⚫ 一个水位线 Watermark(t)，表示在当前流中事件时间已经达到了时间戳 t, 这代表 t 之
                    前的所有数据都到齐了，之后流中不会出现时间戳 t’ ≤ t 的数据
                    水位线是 Flink 流处理中保证结果正确性的核心机制，它往往会跟窗口一起配合，完成对
                    乱序数据的正确处理。

                    处理乱序数据的方案： 设置延迟时间

     6.2.3 如何生成水位线
        1、生成水位线总体原则

        2、水位线生成策略：
            1）默认周期性生成水位线的时间间隔为 200 ms ，可以通过
                env.getConfig().setAutoWatermarkInterval(100)

            2) 在什么时候生成水位线呢？
                离数据源越近， 后面对时间的控制越精确

            3）通过什么来生成水位线呢？
                （1） 生成水位线是 DataStream 的方法 assignTimestampsAndWatermarks

            4）怎么生成？
                （1） stream.assignTimestampsAndWatermarks(new WatermarkStragy()) --》 可以自己 new ，但是太麻烦

                // 有序：只测试使用， 有序流的 watermark 生成 ： monotonous 单调的，非乱序的
                //        stream.assignTimestampsAndWatermarks(
                //                // 参数为 WatermarkStrategy ，对于 有序的数据流，指定泛型调用 forMonotonousTimestamps 返回 WatermarkStrategy
                //                WatermarkStrategy.<Event>forMonotonousTimestamps()
                //                        // 有了水位线，同时还要指定时间戳
                //                .withTimestampAssigner(
                //                  new SerializableTimestampAssigner<Event>() {
                //                    @Override
                //                    public long extractTimestamp(Event element, long recordTimestamp) {
                //                        return element.timestamp;
                //                    }
                //                })
                //        );

                        // 乱序流的 watermark 生成
                        stream.assignTimestampsAndWatermarks(
                                WatermarkStrategy.<Event>forBoundedOutOfOrderness(
                                        Duration.ofMillis(100L)
                                )
                                .withTimestampAssigner(
                                        new SerializableTimestampAssigner<Event>() {
                                            @Override
                                            public long extractTimestamp(Event element, long recordTimestamp) {
                                                return element.timestamp;
                                            }
                                        }
                                )
                        );




































